package ru.merion.aqa.lesson5;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import ru.merion.aqa.WebDriverFactory;

import java.time.Duration;

/*
=== ТИПЫ ОЖИДАНИЙ В SELENIUM ===

1. Thread.sleep() - "жесткое" ожидание
   - Останавливает выполнение потока на фиксированное время
   - Не является best practice, но допустим, если точно известно время ожидания
   - В данном примере: ждем 16 секунд независимо от того, загрузился контент или нет
   - Недостаток: всегда ждет полное время, даже если элемент появился раньше

2. Implicit Wait (Неявное ожидание)
   - Глобальная настройка WebDriver
   - Применяется ко ВСЕМ операциям поиска элементов
   - Механизм работы:
     * При каждом findElement() WebDriver ждет до указанного таймаута (например, 10 сек)
     * Проверяет наличие элемента каждые 500 мс (по умолчанию)
     * Как только элемент найден - сразу возвращает его (не ждет полный таймаут)
   - Полезно при проблемах с сетью (медленный интернет, высокая нагрузка на сервер)

3. Explicit Wait (Явное ожидание) - не показано в этом примере
   - Настраивается для конкретных элементов/условий
   - Более гибкое, чем implicit wait
   - Используется с ExpectedConditions

ВАЖНО: Не рекомендуется смешивать implicit и explicit ожидания!
*/

/**
 * Демонстрация работы с AJAX-контентом и использования неявного ожидания.
 * Пример показывает, как Selenium обрабатывает динамически загружаемый контент.
 */
public class LoadAjaxData {

    public static void main(String[] args) {
        // Инициализация WebDriver для браузера Chrome
        WebDriver driver = WebDriverFactory.create("chrome");

        // ========== НАСТРОЙКА НЕЯВНОГО ОЖИДАНИЯ ==========
        // implicitlyWait устанавливает глобальный таймаут для всех findElement()
        // Если элемент не найден сразу, WebDriver будет повторять попытки поиска
        // в течение 16 секунд с интервалом ~500 мс между попытками
        // Эта настройка применяется ко ВСЕМ операциям поиска элементов в сессии
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(16));

        // Открываем тестовую страницу с AJAX-загрузкой
        // На этой странице контент подгружается асинхронно после клика по кнопке
        driver.get("http://uitestingplayground.com/ajax");

        // ========== КЛИК ПО КНОПКЕ AJAX ==========
        // Находим кнопку и кликаем по ней
        // После клика начинается асинхронная загрузка контента (~15 секунд)
        // Благодаря implicitWait кнопка будет найдена, даже если страница грузится
        driver.findElement(By.cssSelector("#ajaxButton")).click();

        // ПРОБЛЕМА БЕЗ ОЖИДАНИЯ:
        // Без Thread.sleep() или implicitWait следующая строка упадет с NoSuchElementException,
        // потому что элемент "#content p" появляется только через ~15 секунд после клика

        // ========== АЛЬТЕРНАТИВА: Thread.sleep() ==========
        // Thread.sleep(16 * 1000);
        // Эта строка закомментирована, потому что используется implicitWait
        // Thread.sleep останавливает выполнение на 16 секунд гарантированно
        // Даже если контент загрузится за 5 секунд, программа будет ждать все 16
        // Thread.sleep блокирует весь поток, что неэффективно

        // ========== ПОЛУЧЕНИЕ AJAX-КОНТЕНТА ==========
        // Первый вызов getText() - не сохраняется (возможно, для отладки)
        // implicitWait сработает здесь: WebDriver будет ждать до 16 секунд,
        // пока элемент "#content p" не появится в DOM
        driver.findElement(By.cssSelector("#content p")).getText();

        // Второй вызов - сохраняем текст в переменную
        // Элемент уже найден в предыдущей строке, поэтому этот вызов выполнится быстро
        // Примечание: лучше найти элемент один раз и сохранить в переменную
        String content = driver.findElement(By.cssSelector("#content p")).getText();

        // Выводим полученный текст в консоль
        // Ожидаемый результат: "Data loaded with AJAX get request."
        System.out.println(content);

        // ========== ЗАКРЫТИЕ БРАУЗЕРА ==========
        // Освобождаем ресурсы и закрываем браузер
        driver.quit();
    }
}