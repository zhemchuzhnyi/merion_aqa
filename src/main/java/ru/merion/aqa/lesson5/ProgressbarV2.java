/*
Прогресс бар - пример 2 (альтернативное решение с while)
Демонстрация более рискованного подхода к мониторингу прогресса
*/

package ru.merion.aqa.lesson5;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import ru.merion.aqa.WebDriverFactory;

/**
 * Второй вариант решения задачи с прогресс-баром.
 * Отличие от первой версии: использует бесконечный цикл while(true)
 * вместо цикла for с ограничением итераций.
 *
 * ⚠️ ВНИМАНИЕ: Этот подход более опасен, чем первый!
 */
public class ProgressbarV2 {
    public static void main(String[] args) throws InterruptedException {

        // Инициализация WebDriver для браузера Chrome
        WebDriver driver = WebDriverFactory.create("chrome");

        // Открываем страницу с прогресс-баром
        driver.get("http://uitestingplayground.com/progressbar");

        // Запускаем прогресс-бар кликом по кнопке "Start"
        driver.findElement(By.cssSelector("#startButton")).click();

        /*
        ========== АЛЬТЕРНАТИВНОЕ РЕШЕНИЕ С while(true) ==========

        Отличие от первой версии (ProgressBar.java):
        - Первая версия: for (int i = 0; i < 1000; i++) - есть защита от зависания
        - Эта версия: while (true) - БЕСКОНЕЧНЫЙ цикл без защиты

        ⚠️ ПРОБЛЕМЫ ЭТОГО ПОДХОДА:

        1. РИСК БЕСКОНЕЧНОГО ЦИКЛА:
           - Если элемент пропадет из DOM → NoSuchElementException
           - Если прогресс-бар сломается и остановится на 70% → зависание навсегда
           - Если изменится структура страницы → зависание

        2. НЕВОЗМОЖНОСТЬ АВТОМАТИЧЕСКОГО ВОССТАНОВЛЕНИЯ:
           - При ошибке тест повиснет бесконечно
           - Нет таймаута для аварийного завершения
           - CI/CD pipeline может зависнуть на часы

        3. НЕЛЬЗЯ ОСТАВИТЬ БЕЗ ПРИСМОТРА:
           - Требует постоянного мониторинга
           - Не подходит для автоматизированных прогонов
           - Может заблокировать другие тесты в очереди

        4. ПОТРЕБЛЕНИЕ РЕСУРСОВ:
           - Может работать бесконечно, потребляя CPU и память
           - Держит открытым браузер и WebDriver
           - Блокирует executor в CI/CD

        Вывод: Такой подход допустим только для:
        - Локальной отладки с ручным контролем
        - Экспериментов и обучения
        - Временных решений (с планом переписать)
        */

        // ========== БЕСКОНЕЧНЫЙ ЦИКЛ МОНИТОРИНГА ==========
        // while (true) - цикл без условия выхода, работает до явного break
        // ⚠️ ОПАСНО: Нет защиты от зависания!
        while (true) {

            // Получаем текущее значение прогресса
            // ⚠️ РИСК: Если элемент пропадет → NoSuchElementException → зависание
            String value = driver.findElement(By.cssSelector("#progressBar"))
                    .getAttribute("aria-valuenow");

            // Выводим текущее значение для мониторинга
            System.out.println(value);

            // Пауза 100 мс между проверками
            // Без этой паузы цикл "молотил" бы браузер тысячами запросов в секунду
            Thread.sleep(100);

            // ========== ЕДИНСТВЕННОЕ УСЛОВИЕ ВЫХОДА ==========
            // Проверяем: достиг ли прогресс 75%?
            // ⚠️ ПРОБЛЕМА: Если условие никогда не выполнится → вечный цикл
            if (Integer.parseInt(value) >= 75 ) {

                // Останавливаем прогресс-бар
                driver.findElement(By.cssSelector("#stopButton")).click();

                // Выходим из бесконечного цикла
                // break - ЕДИНСТВЕННЫЙ способ завершить while(true)
                break;
            }

            // Если условие не выполнено → цикл продолжается
            // Возвращаемся к началу while
        }
        // ⚠️ До этой строки код дойдет ТОЛЬКО если сработал break
        // Иначе программа зависнет в цикле навсегда

        // Сообщение о завершении
        System.out.println("Finished");

        // Закрываем браузер
        // ⚠️ ПРОБЛЕМА: Если цикл зависнет, браузер никогда не закроется
        driver.quit();
    }
}